# 함수를 통해 객체 복사하기

-동기
177p 에 따르면, 객체는 가변 자료형이기때문에,
전역변수로 선언된 객체를 함수의 인자로 넣러 조작하면 전역 객체가 훼손될 가능성이 있습니다.

책에서는 객체 원본을 훼손하지 않으며 함수에 이용하는, `방어적 객체복사` 에 대해 언급하나,
설명하지 않습니다. 그리하여 지난 과제에서 제가 실제로 `객체복사`를 했던 과제를 소개하며,
트러블 슈팅 및 `방어적 객체복사`에대해 소개합니다.

## 과제 목표

`filterMovie(req,res)` 컨트롤러의 완성

- 컨트롤러의 역할
  유저로부터 입력받은 `year`과 `rating` 정보를 통해,
  필터링된 영화를 담고있는 배열변수 `videos`를 `pug`에 전송해준다.

## problem: - videos배열에 숫자만 담기게 되었다.

for in 반복문을 사용하여 배열의 성분-영화 정보를 담은 객체 을(를)
옮겨주었는데,
어찌된게 videos에는 숫자 문자열만 담기게 되었습니다.

### 오류가 발생한 이유

array의 성분을 지정할때, for in 구문을 사용했기 때문.

```
getMovieByMinimumYear()
getMovieByMinumumRating()
```

이 두함수로 반환되는 값은 배열입니다.
`[{object}]` 형식으로 들어있습니다.

그러므로 저는 반환된 값의 배열을 옮길때
별 생각 없이 for in 을 사용했습니다.

### 코드 설명

```
let videos = [];                    // 화면에 표시할 video를 담을 배열
  if (year !== "") {
    const moviesYear = getMovieByMinimumYear(year); // year에 해당하는 movies들의 배열
    if (moviesYear !== null) {                     // null 체크
      for (let movie in moviesYear) {
        videos.push(movie);        // moviesYear의 원소를 videos로 옮긴다.
      }                            // 이과정에서 문자열 형태의 숫자가 복제되었습니다.
    }
  }

 if (rating !== "") {
    const moviesRating = getMovieByMinimumRating(rating); //rating에 해당하는 movies들의 배열
    if (moviesRating !== null) {
      for (let movie in moviesRating) {  // null 체크
        if (!videos.includes(movie)) {   // videos에 중복성분이 들어가는것을 방지
          videos.push(movie);
        }
      }
    }
  }
```

### 오류 설명

그런데 최종적으로 videos는 문자열 형태의 숫자들이 들어있는 배열이 되었습니다.
영화의 정보를 담고있는 오브젝트가아닌 배열 성분들의 `key` 즉, index 번호가 복제되었습니다.

```
["a", "b", "c"]

//위의 배열은 아래와 같이 인식된다.

{
    0: "a",
    1: "b",
    2: "c",
}
```

### 문제의 원인: for in 반복문

```
for(let item in Object){

}
```

위의 반복문을 사용할시, `item`은 객체의 `key:value` 쌍이 아닌
개별 `key`가 됩니다.

만약에 객체의 성분을 일일히 복사하고싶다면
추가적으로 성분을 언급해주어야 합니다.

```
for(let item in Object) {
    videos.push({item : object[item]})
}
```

간편하게 객체의 성분을 복사하고싶다면,
for of 구문을 사용해야합니다

```
for(let item of Object) {
    videos.push(item)
}
```

저는 for in 구문의 동작원리에 대해 알고있었으나, 배열이 객체라는것을 간과했습니다.

### 해결방법:

for in 구문을 for of 구문으로 바꾸어 고쳤습니다.

### 함수의 목표

위 함수의 목표는 세개의 배열을 중복 원소를 갖지 않게 하나로 합치는 것이었습니다.

# 전역변수 객체(배열)을 사용하지 않는 이유.

`getMovies()` 함수는 영화 오브젝트가 들어있는 배열을 가져옵니다.
그런데 전역 배열을 선언한 후 함수에서 사용하는게 아니라,
함수 내부에서 `getMovies()`를 호출하여 배열을 저장한후, 함수에서만 사용합니다.

하지만 객체의 가변성때문에, 전역객체가 훼손될 위험이 있습니다.

10- 객체 리터럴 참조

왜냐하면, 배열은 객체이고, 객체는 변하기 때문입니다.

```
//전역변수 배열
const videos = ["a","b","c"]

//배열을 입력받는 함수
const printArray = function (myVideos) {
    const newVideos = myVideos;
    newVideos.pop();
    console.log(newVideos);
    return newVideos
}

// 함수 실행
printArray(videos)

//출력 결과
(2) ['a', 'b']
(2) ['a', 'b']

// 전역변수 배열 확인
videos

//출력 결과
(2) ['a', 'b']

```

### 모멘텀 앱의 예시

이것은 우리가 모멘텀 앱을 만들때
Form이나 ul은 전역변수로 선언했습니다.

하지만 값이 계속 바뀌는 input.value는
함수 내부에서 가져오는것도 비슷한 이유라 합니다.

```

// todo리스트 코드


//전역 변수 폼
const loginForm = document.querySelector(".loginForm")

const handleLogin = function (event) {

     /*
     * 중략
     */


    // input 지역변수
    const input = loginForm.querySelector("input");
    const name = input.value;

    //중략
    }

```

## 객체, 배열의 안전한 복제

전역변수의 객체와 배열을 함수에 대입해도,
성분이 바뀌지 않게 하는것을 안전한 복제라고 합니다.

안전하게 복제하며 객체나 배열을 합치는법을 조사해보았습니다.

### 객체 합치기- Object.prototype.assign

(반환객체, 합칠객체..)

1번인자로 반환될 객체, 2번부터 마지막 인자까지는 합칠 객체를 넣어줍니다.

```
const mergeObject = function (A, B) {
    const newObject = Object.assign({}, A, B);
}
```

객체 A와 B에는 변화가 없고,
1번객체에 나머지 객체가 합쳐져서 저장됩니다.

- key가 같은성분이 존재할경우
  후순위 인자로 입력된 객체의 성분으로 덮어씌여집니다.

- array에는 사용하지 마세요

  성분의 index가 객체의 key로 사용됩니다.
  `Object.assign([],[a,b,c],[c,d,f,r])`
  은 `[c,d,r,f]`를 반환합니다.

- 1번 인자의 성분은 변합니다.
  `Object.assign(A,B)`
  를 입력할경우 기존의 A객체의 성분이 바뀝니다.

### 배열 합치기 - Set 자료구조 이용하기

배열끼리 합칠때 객체처럼 사용한다면,
가장짧은 배열의 길이 만큼 모두 공통된 key 값을 갖습니다.

그러므로, Set이라는 자료구조를 사용하는것이 좋습니다.

Set 자료구조는 `for`이나 `spread연산자`(...) 로 순회를 허용하며,
값이 같은 성분은 허용되지 않는 자료구조입니다.

말그대로 집합 입니다.

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Set

```
let array1 = ['a', 'b', 'c'];
let array2 = ['b', 'c', 'd'];
let union = [...new Set([...array1, ...array2])];

```

이렇게되면 array1, array2의 내용을 하나도 수정하지 않고,
겹치는 성분을 중복 저장하지 않는 새로운 배열을 만들 수 있습니다.

- 삼항연산자, Set, spread연산자로 refactoring한 코드

  ```

      let videos = [];
          if (year !== "") {
      const moviesYear = getMovieByMinimumYear(year);
      videos = moviesYear ? moviesYear : []; // nullcheck 후 복사
       }
      if (rating !== "") {
          const moviesRating = getMovieByMinimumRating(rating);
          videos = moviesRating ? [...new Set([...videos, ...moviesRating])] : videos; //  Set을 활용하기
      }
  ```
