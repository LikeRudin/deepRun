# 1주차

Chapter 4. 변수

1) 변수란 무엇이며 왜 사용하는가?

- 저장된 값이며, 이를 재활용하기 위함이다.
- 그렇다면 어째서 변수라는 방식으로 사용하는가? 이에 대해서는 먼저 컴퓨터의 연산에 대하여 생각해보아야 한다. 연산이 이루어지는 방식은 각 피연산자를 메모리에 할당하여 CPU를 통해 연산하고 그 결과를 같은 방식으로 처리한다. 

                                                              
                                                        `let sum = 10 + 20;`

위의 계산 과정은 다음과 같이 나타난다.
    - let sum이 정의될 때, 컴퓨터에서는 메모리를 할당한다.
    - 동시에 그 공간은 sum이라는 이름을 가지게 된다.
    - 피연산자의 연산결과가 sum의 메모리에 2진수로 저장된다. 
    (피연산자 또한 메모리에 값이 올라가지만 명시되지 않은 상태이며 CPU를 통해 연산되고 버려진다. 자세한 내용은 Heap과 Stack 메모리 영역, 가비지 컬렉터를 통해 확인.)

이런 과정이 끝난 후 sum이라 명시된 변수는 차후 호출될 때 가지고 있는 주소값으로 Reference 된다.(변수,함수명 등은-identifier- 메모리주소값을 가지고 있다.)

2) Undefined

                                                            `var score`

- 위와 같이 변수명을 통해 메모리 공간을 확보한 상황에서 별다른 값을 할당하지 않았을 경우
비어있는 메모리에 Javascript engine은 undefined라는 값을 암묵적으로 초기화한다.
이렇게 하는 이유는 위에서 잠깐 언급된 버려지는 값과 연관이 있는데, 메모리를 무작위로 할당했을 경우 아직 정리되지 않은 값이 있을 수 있으므로 해당 메모리를 초기화하기 위함이다.

3) Hoisting

```jsx
console.log(score);
var score;
```

- 위와 같은 경우 인터프리터에 의해 순차적으로 진행된다면 score가 존재하기 전이므로 참조에 문제가 있을 것이다. 그러나 Javascript engine은 Runtime 이전에(소스코드 실행전) 모든 선언문을 먼저 찾아 실행한 뒤에 나머지를 순차적으로 진행한다. 이것을 Hoisting이라 한다.

4)값의 재할당

- 값을 할당할 때 기본적으로 undefined로 초기화 후에 할당되는데 결국은 이 또한 재할당으로 볼수 있다. (단, const의 경우 이런방식으로 초기화되지 않는다.)즉 같은 방식으로 재할당이 이루어질 때는 undefined가 초기화 된 값을 덮어쓰는 것이 아닌(기존의 주소값이 아닌) 새로운 공간에 할당이 이루어진다.

 

 Chapter 5. 표현식과 문

1) 값과 리터럴의 차이

- 값은 데이터 타입을 가지고 2진수로 저장된다. 따라서 우리가 위에서 다룬 할당되는 것들은 모두 값이라고 볼 수 있다. 그렇다면 리터럴과의 차이는 무엇일까?
리터럴은 사람이 이해할 수 있는 문자나 기호 등으로 표기법을 의미한다.
즉, 초점이 사람을 기준으로 맞춰진 것이며 반대로 값은 컴퓨터에 맞춰진 것으로 생각해 볼 수 있을 듯 하다.

2) 표현식

- 표현식은 값으로 평가될 수 있는 문으로 리터럴 또한 표현식에 포함된다.

3)문

- 프로그램을 구성하는 기본단위임과 동시에 최소 실행단위이며 또한 토큰의 집합체이다.

etc.

변수는 타입을 가지지 않지만, 값은 타입을 가진다.

NaN의 경우 NaN === NaN => false.. 유일한 케이스.
따라서 NaN을 확인하기 위해서는 Number.isNaN()을 사용.

숫자 0의경우도 예외의 경우인데,  0 === -0 같은 경우 ture.

삼항조건연산자 ternary operator(Conditional operator)

[1주차(JS - Deep Dive)](https://www.notion.so/1-JS-Deep-Dive-e549432d5cec48c69f7bfb225c4086de)