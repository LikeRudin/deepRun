# 3주차

# **스코프**

```jsx
var z; //전역변수로 어디서든 참조가능하다.

function add(x, y){
	//매개변수는 함수 내부에서 사용가능
  //해당 매개변수의 scope는 함수 몸체 내부.
console.log(x, y);
return x + y;
}

add(2,5);

console.log(x,y); //ReferenceError: x is not defined 

//이러한 scope내에서 변수를 식별하기 위해선 Unique 해야한다.
//그러나 var와 같은 키워드는 예외인데 중복된 것 중 후자의 초기화를 이용하게된다.
//전역변수의 특성상 접근이 쉬우며, 그러므로 변경 또한 쉬우므로 사용에 신중해야한다.
```

**Lexical environment/Execution context**

Lexical environment는 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 말하며 Execution context 는 이를 구현한 것이다.

**스코프 체인**

변수 참조 시 javascript 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 이는 물리적인 실체로 존재하며, Lexical Enviornmnet을 실제로 생성한다. 변수 선언이 실행되면 변수 식별자가 이 자료구조(렉시컬 환경)에 키로 등록되고, 변수 할당이 일어나면 이 자료구조의 변수 식별자에 해당하는 값을 변경한다. 변수의 검색 또한 이 자료구조 상에서 이루어진다.(json 형태)

```jsx
function foo(){
...
}

function bar(){
	//중첩 함수
	function foo(){
	....
	}
	foo();
}

bar();

// 함수 선언문으로 정의 시 런타임 이전에 함수객체가 생성된다.
// 그리고 자바스크립트 엔진은 함수이름과 동일한 이름의 식별자를 
// 암묵적으로 선언하고 생성된 함수 객체를 할당한다.
// 따라서 위 예제의 모든 함수는 함수 이름과 동일한 이름의 식별자에 할당된다.
// var의 사례와 같이 이러한 경우 후자가 적용되므로 inner function이 적용된다.
// 단, 이는 foo의 호출이 지역변수이기 때문이다.
// 만약 foo()가 외부에서 호출되었다면 outer function이 적용되었을 것.
// 이에 대한 내용은 아래의 변수에서 다시 이야기한다.

```

**함수 레벨 스코프**

지역은 함수 몸체 내부를 이야기한다.

이 이야기는 코드 블록(if,for,while etc..)이 아닌 함수에 의해서만 지역 스코프가 생성된다는 것.

그러나 이러한 특징은 var만 해당되며 let과 const는 코드 블록단위로 적용된다.

**렉시컬 스코프**

```jsx
var x = 1;

function foo(){
	var x = 10;
	bar();
}

function bar(){
	console.log(x);
}

foo();
bar();

// 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정.
// 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정.
// 첫번째를 동적 스코프(dynamic sope)라 하며, 두번째를 렉시컬 스코프(Lexical scope)라 한다.
// Javascript는 렉시컬 스코프이며, 따라서 함수가 호출된 위치는 상위 스코프 결정에
// 어떠한 영향도 주지 않는다.
// 위를 기반으로 생각해보면 bar는 전역으로 정의되었고
// 따라서 foo()에서 호출시 문제가 없다.
```

**변수의 생명주기**

```jsx
function foo(){
	var x = 10;
	console.log(x);
	return x;
}

foo();
console.log(x); //ReferenceError: x is not defined

// x는 지역변수이므로 foo 함수와 생명주기를 같이한다.
// 그러나 변수의 생명주기의 정확한 시점은 메모리 공간을 확보하고
// 그 공간이 해제되어 가용메모리 풀에 반환되는 시점으로
// 만약 누군가가 해당 변수의 메모리를 참조하고 있다면 함수는 소멸되어도
// 변수는 참조가 끝날때까지 남아있을 수 있다.

var x = 'global';

function foo(){
	console.log(x); // 1번
	var x = 'local';
}

foo();
console.log(x); // global

// 1번에서 x는 선언되어 있는 시점이며(Hoisting) undefined로 초기화되어있다.
// 따라서 var의 특성상 후자에 올라간 x가 적용됨을 알 수 있다.
// 그러나 변수 할당문이 실행되기 전까지는 undefined로 초기화된 상태.
// 이를 통해 Hoisting이 scope를 따라감을 알 수 있다.
```

**Let**

var의 경우 중복, 함수레벨의 스코프가 허용되나 Let은 중복되지 않으며 블록레벨의 스코프를 따른다.

또한 호이스팅에 있어서도 차이가 있는데 이는 **var의 경우 선언과 동시에 초기화가 이루어지지만(undefined의 할당)** **let의 경우 선언과 초기화가 나누어져 일어나므로 참조가 불가능한 구간이 생기는데 이러한 구간의 명칭을 TDZ**라 부른다.

마지막으로 var 키워드의 경우 전역 변수,함수와 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역객체 window의 프로퍼티가 되지만, let 키워드는 보이지 않는 개념적인 블록(렉시컬 환경의 선언적 환경 레코드—실행 컨텍스트 참조—)내에 존재하게 된다. 

**Const**

const 키워드는 반드시 선언과 동시에 초기화해야 한다.(명시적인 할당)

대부분은 let과 동일하지만 재할당이 금지되는 부분의 차이가 있으며, 재할당 또한 변수에 객체를 할당한 경우 값을 변경할 수 있다.(참조값—주소값—이 변경되지 않으므로 실제로는 const 키워드가 가진 값이 변경되는 것은 아닌 것.) 

etc

객체밀봉, 객체동결, 불변객체